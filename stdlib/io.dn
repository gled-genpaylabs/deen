extern "C" fn getchar() char;
extern "C" fn printf(*char, ...);

extern "C" fn fflush(*i8);
extern "C" fn fprintf(*i8, *char, ...);

// standart streams
_extern_declare stdout **i8
_extern_declare stderr **i8
_extern_declare stdin **i8

include "@string";

// standart input
pub struct Stdin {
  fn read_line(buffer: *String) {
    let ch = getchar();
    while (ch != '\0') {
      if ch == '\n' || ch == '\0' {
        break;
      }

      buffer.push(ch);
      ch = getchar();
    }
  }

  fn getchar() char {
    let chr = getchar();
    return chr;
  }
}

// output streams
pub struct Stdout {
  fn print(input: *char) {
    printf("%s", input);
  }

  fn println(input: *char) {
    printf("%s\n", input);
  }

  fn flush() {
    fflush(*stdout);
  }
}

pub struct Stderr {
  fn print(input: *char) {
    fprintf(*stderr, "%s", input);
  }

  fn println(input: *char) {
    fprintf(*stderr, "%s\n", input);
  }

  fn flush() {
    fflush(*stderr);
  }
}

// file system

extern "C" fn fopen(*char, *char) *void;
extern "C" fn fclose(*void) i32;

extern "C" fn fgetc(*void) char;
extern "C" fn rewind(*void);
extern "C" fn feof(*void) bool;

pub enum FileMode {
  Read,
  ReadBinary,

  Write,
  WriteBinary,

  Append,
  AppendBinary,

  ReadWrite,
  ReadAppend,
}

struct ModeHandler {
  fn specify(mode: FileMode) *char {
    // I know this looks awful, but I'll return here when switch statements will appear
    if mode == FileMode.Read { return "r" }
    else if mode == FileMode.ReadBinary { return "rb" }
    else if mode == FileMode.Write { return "w" }
    else if mode == FileMode.WriteBinary { return "wb" }
    else if mode == FileMode.Append { return "a" }
    else if mode == FileMode.AppendBinary { return "ab" }
    else if mode == FileMode.ReadWrite { return "r+" }
    else if mode == FileMode.ReadAppend { return "a+" }
    else { return "r+" }
  }
}

pub struct File {
  path: String,
  mode: FileMode,
  is_open: bool,

  ptr: *void,

  fn open(filename: *char, mode: FileMode) File {
    // TODO: Add error handling by NULL checker

    let str_mode = ModeHandler.specify(mode);
    let ptr = fopen(filename, str_mode);

    let is_open = ptr != NULL;

    return File { .path = String.from(filename), .mode = mode, .ptr = ptr, .is_open = is_open };
  }

  fn close(&self) i32 {
    if self.is_open {
      self.is_open = false;
      return fclose(self.ptr);
    }
    return -1;
  }

  fn opened(&self) bool {
    return self.is_open;
  }

  fn rewind(&self) {
    if self.is_open {
      rewind(self.ptr);
    }
  }

  fn get_char(&self) char {
    if self.is_open == true && !feof(self.ptr) {
      let chr = fgetc(self.ptr);
      if feof(self.ptr) {
        return '\0'
      };

      return chr;
    }

    return '\0';
  }

  fn read_to_string(&self) String {
    if !self.is_open {
      panic!("Unable to read dropped file");
    }

    let buffer = String.new();
    
    while !feof(self.ptr) {
      let chr = fgetc(self.ptr);
      if feof(self.ptr) { break };
      buffer.push(chr);
    }

    if buffer.peek(buffer.len() - 1) == '\n' {
      let _ = buffer.pop();
    }

    self.rewind();
    return buffer;
  }

  // compiler's tech
  fn drop(&self) {
    let dropping_string = self.path; // will be freed automatically
    let _ = self.close();
  }
}
