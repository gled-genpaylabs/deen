extern "C" fn getchar() char;
extern "C" fn printf(*char, ...);

extern "C" fn fflush(*i8);
extern "C" fn fprintf(*i8, *char, ...);

// standart streams
_extern_declare stdout **i8
_extern_declare stderr **i8
_extern_declare stdin **i8

include "@string";
include "@bytes";

// standart input
pub struct Stdin {
  fn read_line(buffer: *String) {
    let ch = getchar();
    while (ch != '\0') {
      if ch == '\n' || ch == '\0' {
        break;
      }

      buffer.push(ch);
      ch = getchar();
    }
  }

  fn getchar() char {
    let chr = getchar();
    return chr;
  }
}

// output streams
pub struct Stdout {
  fn print(input: *char) {
    printf("%s", input);
  }

  fn println(input: *char) {
    printf("%s\n", input);
  }

  fn flush() {
    fflush(*stdout);
  }
}

pub struct Stderr {
  fn print(input: *char) {
    fprintf(*stderr, "%s", input);
  }

  fn println(input: *char) {
    fprintf(*stderr, "%s\n", input);
  }

  fn flush() {
    fflush(*stderr);
  }
}

// file system

extern "C" fn fopen(*char, *char) *void;
extern "C" fn fclose(*void) i32;
extern "C" fn feof(*void) bool;

extern "C" fn fgetc(*void) char;
extern "C" fn fputc(char, *void) i32;
extern "C" fn fread(*void, usize, usize, *void);
extern "C" fn fwrite(*void, usize, usize, *void);

extern "C" fn rewind(*void);
extern "C" fn ftell(*void) usize;
extern "C" fn fseek(*void, usize, i32);

pub enum IOError {
  None,
  WriteableOutOfRange,
  WriteableModeException,
  ReadableModeException,
  StdlibException,
}

pub enum FileMode {
  Read,
  ReadBinary,

  Write,
  WriteBinary,

  Append,
  AppendBinary,

  ReadWrite,
  ReadAppend,
}

struct ModeHandler {
  fn specify(mode: FileMode) *char {
    // I know this looks awful, but I'll return here when switch statements will appear
    if mode == FileMode.Read { return "r" }
    else if mode == FileMode.ReadBinary { return "rb" }
    else if mode == FileMode.Write { return "w" }
    else if mode == FileMode.WriteBinary { return "wb" }
    else if mode == FileMode.Append { return "a" }
    else if mode == FileMode.AppendBinary { return "ab" }
    else if mode == FileMode.ReadWrite { return "r+" }
    else if mode == FileMode.ReadAppend { return "a+" }
    else { return "r+" }
  }
}

pub struct IOErrorHandler {
  fn specify(err: IOError) *char {
    if err == IOError.WriteableModeException { return "Writeable stream has no mode permissions" }
    else if err == IOError.ReadableModeException { return "Readable stream has no mode permessions" }
    else {
      return "None"
    }
  }
}

// SEEK_END = 2
// EOF = -1
pub struct File {
  path: String,
  mode: FileMode,
  is_open: bool,

  size: usize,
  ptr: *void,

  fn open(filename: *char, mode: FileMode) File {
    let str_mode = ModeHandler.specify(mode);
    let ptr = fopen(filename, str_mode);

    let is_open = ptr != NULL;

    fseek(ptr, 0, 2); // 2 is SEEK_END
    let fsize = ftell(ptr);

    rewind(ptr);
    return File { .path = String.from(filename), .mode = mode, .ptr = ptr, .is_open = is_open, .size = fsize };
  }

  fn close(&self) i32 {
    if self.is_open {
      self.is_open = false;
      return fclose(self.ptr);
    }
    return -1;
  }

  fn opened(&self) bool {
    return self.is_open;
  }

  fn size(&self) usize {
    return self.size;
  }

  fn rewind(&self) {
    if self.is_open {
      rewind(self.ptr);
    }
  }

  fn get_char(&self) char {
    if self.is_open == true && !feof(self.ptr) {
      let chr = fgetc(self.ptr);
      if feof(self.ptr) {
        return '\0'
      };

      return chr;
    }

    return '\0';
  }

  fn read(&self) Bytes {
    if !self.is_open {
      panic!("Unable to read dropped file: `File.read`");
    }

    let buffer = Bytes.with_size(self.size);
    let buffer_ptr = buffer.ptr;

    let size: usize = self.size;
    let pos: usize = 0;

    while pos < size {
      fread(buffer_ptr + pos, 1, 1, self.ptr);
      pos += 1;
    }

    rewind(self.ptr);
    return buffer;
  }

  fn read_string(&self) String {
    if !self.is_open {
      panic!("Unable to read dropped file: `File.read_to_string`");
    }

    let buffer = String.new();
    
    while !feof(self.ptr) {
      let chr = fgetc(self.ptr);
      if feof(self.ptr) { break };
      buffer.push(chr);
    }

    if buffer.peek(buffer.len() - 1) == '\n' {
      let _ = buffer.pop();
    }

    self.rewind();
    return buffer;
  }

  fn write(&self, bytes: *Bytes) IOError {
    if self.mode != FileMode.Write && self.mode != FileMode.WriteBinary
    && self.mode != FileMode.Append && self.mode != FileMode.AppendBinary
    && self.mode != FileMode.ReadWrite && self.mode != FileMode.ReadAppend {
      return IOError.WriteableModeException;
    }

    fwrite(bytes.ptr, 1, bytes.len, self.ptr);

    // re-calculating size
    fseek(self.ptr, 0, 2); // 2 is SEEK_END
    let fsize = ftell(self.ptr);
    rewind(self.ptr);

    self.size = fsize;

    return IOError.None;
  }

  fn write_string(&self, value: *String) IOError {
    if self.mode != FileMode.Write && self.mode != FileMode.WriteBinary
    && self.mode != FileMode.Append && self.mode != FileMode.AppendBinary
    && self.mode != FileMode.ReadWrite && self.mode != FileMode.ReadAppend {
      return IOError.WriteableModeException;
    }   

    let raw_string = value.raw();

    let pos = 0;
    let chr = raw_string[pos];

    while pos < value.len {
      if chr == '\0' { break };
      fputc(chr, self.ptr);

      pos += 1;
      chr = raw_string[pos];
    }

    // re-calculating size
    fseek(self.ptr, 0, 2); // 2 is SEEK_END
    let fsize = ftell(self.ptr);
    rewind(self.ptr);

    self.size = fsize;

    return IOError.None;
  }

  fn write_str(&self, value: *char) IOError {
    if self.mode != FileMode.Write && self.mode != FileMode.WriteBinary
    && self.mode != FileMode.Append && self.mode != FileMode.AppendBinary
    && self.mode != FileMode.ReadWrite && self.mode != FileMode.ReadAppend {
      return IOError.WriteableModeException;
    }   

    let raw_string = value;

    let pos = 0;
    let chr = raw_string[pos];

    while chr != '\0' {
      if chr == '\0' { break };
      fputc(chr, self.ptr);

      pos += 1;
      chr = raw_string[pos];
    }

    // re-calculating size
    fseek(self.ptr, 0, 2); // 2 is SEEK_END
    let fsize = ftell(self.ptr);
    rewind(self.ptr);

    self.size = fsize;

    return IOError.None;
  }

  // compiler's tech
  fn drop(&self) {
    let dropping_string = self.path; // will be freed automatically
    let _ = self.close();
  }
}
